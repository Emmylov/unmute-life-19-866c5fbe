
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

export const SUPABASE_URL = "https://kjjnnzwtqniqmaupecle.supabase.co";
export const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtqam5uend0cW5pcW1hdXBlY2xlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwOTc3NzksImV4cCI6MjA1NjY3Mzc3OX0.IUDdVHk3fcyLLcuWn-CK83pkf0IKESQ_94NuRvRsITY";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_KEY);

// Available storage buckets in the project
export const STORAGE_BUCKETS = {
  REELS: 'reels',
  POSTS: 'posts',
  STORIES: 'stories',
  AVATARS: 'avatars',
  MESSAGES: 'messages',
};

// Storage helper functions
export const getPublicUrl = (bucket: string, path: string): string => {
  const { data } = supabase.storage.from(bucket).getPublicUrl(path);
  return data.publicUrl;
};

// Function to list all files in a bucket
export const listBucketFiles = async (bucket: string, path: string = '') => {
  const { data, error } = await supabase.storage.from(bucket).list(path);
  
  if (error) {
    console.error(`Error listing files in bucket ${bucket}:`, error);
    return null;
  }
  
  return data;
};

// Function to get metadata for multiple files from a bucket
export const getFilesMetadata = async (bucket: string, paths: string[]) => {
  const promises = paths.map(async (path) => {
    const { data, error } = await supabase.storage.from(bucket).list(path, {
      limit: 100,
      offset: 0,
      sortBy: { column: 'name', order: 'asc' },
    });
    
    if (error) {
      console.error(`Error getting metadata for ${path}:`, error);
      return null;
    }
    
    return data;
  });
  
  return Promise.all(promises);
};

// Fetch all files from multiple buckets
export const fetchAllContentFromBuckets = async (buckets: string[]) => {
  const results: Record<string, any[]> = {};
  
  for (const bucket of buckets) {
    const files = await listBucketFiles(bucket);
    if (files) {
      results[bucket] = files.map(file => ({
        ...file,
        bucket,
        publicUrl: getPublicUrl(bucket, file.name || '')
      }));
    } else {
      results[bucket] = [];
    }
  }
  
  return results;
};

// Match storage files with database metadata if available
export const matchStorageWithDatabaseMetadata = async (
  bucket: string, 
  files: any[], 
  tableName: string, 
  fileUrlField: string = 'video_url'
) => {
  if (!files || files.length === 0) return [];
  
  // Use type assertion to bypass TypeScript's table name checking
  // This is needed because we're accepting a dynamic table name as a parameter
  const { data: metadata, error } = await (supabase as any)
    .from(tableName)
    .select('*');
  
  if (error) {
    console.error(`Error fetching metadata from ${tableName}:`, error);
    return files.map(file => ({
      file,
      metadata: null,
      publicUrl: getPublicUrl(bucket, file.name || '')
    }));
  }
  
  // Match files with their metadata
  return files.map(file => {
    const publicUrl = getPublicUrl(bucket, file.name || '');
    const matchedMetadata = metadata?.find((meta: any) => 
      meta[fileUrlField]?.includes(file.name) || 
      meta[fileUrlField] === publicUrl
    );
    
    return {
      file,
      metadata: matchedMetadata || null,
      publicUrl
    };
  });
};
